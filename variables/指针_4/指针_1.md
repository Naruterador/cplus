## 指针(pointer)
- 是指向(point to)另一种类型的符合类型。
- 与引用类似，指针本身也实现了对对象的间接访问
- 指针本身就是一个对象
- 指针无需在定义时赋值
- 在块作用域内的指针，如果没有被初始化，也将拥有一个不确定的值

#### 定义指针


```c++
//定义指针类型的方法将声明符写成*d的形式，其中d是变量名。

int *ip1 , *ip2; //ip1和ip2都是指向int型对象的指针
double dp , *dp2 //dp2是指向double型对象的指针，dp是double型对象

```

#### 获取对象的地址

- **如果想要获取地址，需要使用取地址符&**
```c++
int ival = 42;
int * p = &ival; //p存放变量ival的地址，或者说p是指向变量ival的指针
```

- **因为引用不是对象，没有实际地址，所以不能定义指向引用的指针**




```c++
double dval;
double *pd = &dval; //正确：初始值是double型对象的地址
double *pd2 = pd;  //正确:初始值是指向double对象的指针

int *pi = pd; //错误：指针pi的类型和pd类型不匹配
pi = &dval;  //错误:试图把double型对象的地址赋给int型指针
```

#### 指针值
- 指针的值（也就是地址）应属下列4中状态之一：
   - 指向一个对象
   - 指向紧邻对象所占空间的下一个位置
   - 空指针，也就是指针没有任何对象
   - 无效指针，也就是上述情况之外的其他值


#### 利用指针访问对象
- 如果一个指针指向一个对象，可以使用**解引用符(操作符*)**来访问对象:

```c++
int ival = 42;
int *p = &ival;   //p存放着变量ival的地址，或者说p是指向变量ival的指针
cout << *p;    //由符号*得到指针p所指的对象，输出42
```

- 对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值

```c++
*p = 0;      //由符号*得到指针p所指的对象，即可经由p为变量ival赋值
cout << *p   //输出0

//*p赋值实际上是为p所指的对象赋值
//解引操作仅适用于那些确实指向了某个对象的有效指针
```

####  空指针(null pointer)
- 空指针不指向任何对象

```c++
int * p1 = nullptr; //等于int * p1 = 0;
int * p2 = 0;  //直接将p2初始化为字面值常量0

//需要首先#include cstdlib
int * p3 = NULL; //等价于int * p3 = 0;

//得到空指针最直接的办法就是用字面值nullptr来初始化指针,要尽量避免使用NULL




int * pi = nullptr;
int zero = 0;
pi = zero;     //错误:不能把yint变量直接赋给指针

```

> **使用未经初始化的指针式引发运行时错误的一大原因。**

```c++
int i = 42;
int *pi = 0;         //pi被初始化，但是没有指向任何对象
int *pi2 = &i;       //pi2倍初始化，存有i的地址
int *pi3;            //如果pi3定义与块内，则pi3的值是无法确定的

pi3 = pi2;    //pi3和pi2指向同一个对象i
pi2 = 0;      //pi2不指向任何对象了

pi = &val;    //pi的值被改变，现在指向了ival
*pi = 0;      //ival的值被改变，指针pi并没有改变
```

#### void* 指针
- void*是一种特殊的指针类型，可用于存放任意对象的地址
- 一个void*存放着一个地址，这一点和其他指针类似
- 我们对该地址中到底是什么类型的对象并不了解

```c++

   double obj = 3.14;
   double *pd = &obj;  //正确：void*能存放任意类型的对象的地址

   void *pv = & obj //obj可以是任意类型的对象
   pv = pd; //pv可以存放任意类型的指针
```



